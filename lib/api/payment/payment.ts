/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Marketplace API
 * Multi-vendor marketplace API ‚Äî Express, TypeScript, Prisma. Auto-generated from Zod schemas.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  GetPaymentsHistory200,
  GetPaymentsHistory500,
  GetPaymentsHistoryParams,
  GetPaymentsPaymentId200,
  GetPaymentsPaymentId400,
  PostPaymentsInitialize200,
  PostPaymentsInitialize400,
  PostPaymentsInitializeBody,
  PostPaymentsPaymentIdRefund200,
  PostPaymentsPaymentIdRefund400,
  PostPaymentsPaymentIdRefundBody,
  PostPaymentsVerify200,
  PostPaymentsVerify400,
  PostPaymentsVerifyBody,
  PostPaymentsWebhook200,
  PostPaymentsWebhook401,
  PostPaymentsWebhook500,
  PostPaymentsWebhookBody
} from '../marketplaceAPI.schemas';





/**
 * Initialize a new payment with Paystack for an order
 * @summary Initialize Paystack payment
 */
export const postPaymentsInitialize = (
    postPaymentsInitializeBody: PostPaymentsInitializeBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostPaymentsInitialize200>> => {
    
    
    return axios.post(
      `http://localhost:4000/payments/initialize`,
      postPaymentsInitializeBody,options
    );
  }



export const getPostPaymentsInitializeMutationOptions = <TError = AxiosError<PostPaymentsInitialize400>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPaymentsInitialize>>, TError,{data: PostPaymentsInitializeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postPaymentsInitialize>>, TError,{data: PostPaymentsInitializeBody}, TContext> => {

const mutationKey = ['postPaymentsInitialize'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPaymentsInitialize>>, {data: PostPaymentsInitializeBody}> = (props) => {
          const {data} = props ?? {};

          return  postPaymentsInitialize(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostPaymentsInitializeMutationResult = NonNullable<Awaited<ReturnType<typeof postPaymentsInitialize>>>
    export type PostPaymentsInitializeMutationBody = PostPaymentsInitializeBody
    export type PostPaymentsInitializeMutationError = AxiosError<PostPaymentsInitialize400>

    /**
 * @summary Initialize Paystack payment
 */
export const usePostPaymentsInitialize = <TError = AxiosError<PostPaymentsInitialize400>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPaymentsInitialize>>, TError,{data: PostPaymentsInitializeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postPaymentsInitialize>>,
        TError,
        {data: PostPaymentsInitializeBody},
        TContext
      > => {

      const mutationOptions = getPostPaymentsInitializeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Verify the status of a payment using the reference
 * @summary Verify payment status
 */
export const postPaymentsVerify = (
    postPaymentsVerifyBody: PostPaymentsVerifyBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostPaymentsVerify200>> => {
    
    
    return axios.post(
      `http://localhost:4000/payments/verify`,
      postPaymentsVerifyBody,options
    );
  }



export const getPostPaymentsVerifyMutationOptions = <TError = AxiosError<PostPaymentsVerify400>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPaymentsVerify>>, TError,{data: PostPaymentsVerifyBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postPaymentsVerify>>, TError,{data: PostPaymentsVerifyBody}, TContext> => {

const mutationKey = ['postPaymentsVerify'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPaymentsVerify>>, {data: PostPaymentsVerifyBody}> = (props) => {
          const {data} = props ?? {};

          return  postPaymentsVerify(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostPaymentsVerifyMutationResult = NonNullable<Awaited<ReturnType<typeof postPaymentsVerify>>>
    export type PostPaymentsVerifyMutationBody = PostPaymentsVerifyBody
    export type PostPaymentsVerifyMutationError = AxiosError<PostPaymentsVerify400>

    /**
 * @summary Verify payment status
 */
export const usePostPaymentsVerify = <TError = AxiosError<PostPaymentsVerify400>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPaymentsVerify>>, TError,{data: PostPaymentsVerifyBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postPaymentsVerify>>,
        TError,
        {data: PostPaymentsVerifyBody},
        TContext
      > => {

      const mutationOptions = getPostPaymentsVerifyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Get the payment history for the authenticated user
 * @summary Get payment history
 */
export const getPaymentsHistory = (
    params?: GetPaymentsHistoryParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetPaymentsHistory200>> => {
    
    
    return axios.get(
      `http://localhost:4000/payments/history`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetPaymentsHistoryQueryKey = (params?: GetPaymentsHistoryParams,) => {
    return [`http://localhost:4000/payments/history`, ...(params ? [params]: [])] as const;
    }

    
export const getGetPaymentsHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentsHistory>>, TError = AxiosError<GetPaymentsHistory500>>(params?: GetPaymentsHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentsHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentsHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentsHistory>>> = ({ signal }) => getPaymentsHistory(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPaymentsHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPaymentsHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentsHistory>>>
export type GetPaymentsHistoryQueryError = AxiosError<GetPaymentsHistory500>


export function useGetPaymentsHistory<TData = Awaited<ReturnType<typeof getPaymentsHistory>>, TError = AxiosError<GetPaymentsHistory500>>(
 params: undefined |  GetPaymentsHistoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentsHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentsHistory>>,
          TError,
          Awaited<ReturnType<typeof getPaymentsHistory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentsHistory<TData = Awaited<ReturnType<typeof getPaymentsHistory>>, TError = AxiosError<GetPaymentsHistory500>>(
 params?: GetPaymentsHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentsHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentsHistory>>,
          TError,
          Awaited<ReturnType<typeof getPaymentsHistory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentsHistory<TData = Awaited<ReturnType<typeof getPaymentsHistory>>, TError = AxiosError<GetPaymentsHistory500>>(
 params?: GetPaymentsHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentsHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get payment history
 */

export function useGetPaymentsHistory<TData = Awaited<ReturnType<typeof getPaymentsHistory>>, TError = AxiosError<GetPaymentsHistory500>>(
 params?: GetPaymentsHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentsHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPaymentsHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get detailed information about a specific payment
 * @summary Get payment details
 */
export const getPaymentsPaymentId = (
    paymentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetPaymentsPaymentId200>> => {
    
    
    return axios.get(
      `http://localhost:4000/payments/${paymentId}`,options
    );
  }


export const getGetPaymentsPaymentIdQueryKey = (paymentId: string,) => {
    return [`http://localhost:4000/payments/${paymentId}`] as const;
    }

    
export const getGetPaymentsPaymentIdQueryOptions = <TData = Awaited<ReturnType<typeof getPaymentsPaymentId>>, TError = AxiosError<GetPaymentsPaymentId400>>(paymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentsPaymentId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPaymentsPaymentIdQueryKey(paymentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentsPaymentId>>> = ({ signal }) => getPaymentsPaymentId(paymentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(paymentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPaymentsPaymentId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPaymentsPaymentIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPaymentsPaymentId>>>
export type GetPaymentsPaymentIdQueryError = AxiosError<GetPaymentsPaymentId400>


export function useGetPaymentsPaymentId<TData = Awaited<ReturnType<typeof getPaymentsPaymentId>>, TError = AxiosError<GetPaymentsPaymentId400>>(
 paymentId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentsPaymentId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentsPaymentId>>,
          TError,
          Awaited<ReturnType<typeof getPaymentsPaymentId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentsPaymentId<TData = Awaited<ReturnType<typeof getPaymentsPaymentId>>, TError = AxiosError<GetPaymentsPaymentId400>>(
 paymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentsPaymentId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentsPaymentId>>,
          TError,
          Awaited<ReturnType<typeof getPaymentsPaymentId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPaymentsPaymentId<TData = Awaited<ReturnType<typeof getPaymentsPaymentId>>, TError = AxiosError<GetPaymentsPaymentId400>>(
 paymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentsPaymentId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get payment details
 */

export function useGetPaymentsPaymentId<TData = Awaited<ReturnType<typeof getPaymentsPaymentId>>, TError = AxiosError<GetPaymentsPaymentId400>>(
 paymentId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPaymentsPaymentId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPaymentsPaymentIdQueryOptions(paymentId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Process a refund for a payment
 * @summary Refund payment
 */
export const postPaymentsPaymentIdRefund = (
    paymentId: string,
    postPaymentsPaymentIdRefundBody: PostPaymentsPaymentIdRefundBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostPaymentsPaymentIdRefund200>> => {
    
    
    return axios.post(
      `http://localhost:4000/payments/${paymentId}/refund`,
      postPaymentsPaymentIdRefundBody,options
    );
  }



export const getPostPaymentsPaymentIdRefundMutationOptions = <TError = AxiosError<PostPaymentsPaymentIdRefund400>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPaymentsPaymentIdRefund>>, TError,{paymentId: string;data: PostPaymentsPaymentIdRefundBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postPaymentsPaymentIdRefund>>, TError,{paymentId: string;data: PostPaymentsPaymentIdRefundBody}, TContext> => {

const mutationKey = ['postPaymentsPaymentIdRefund'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPaymentsPaymentIdRefund>>, {paymentId: string;data: PostPaymentsPaymentIdRefundBody}> = (props) => {
          const {paymentId,data} = props ?? {};

          return  postPaymentsPaymentIdRefund(paymentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostPaymentsPaymentIdRefundMutationResult = NonNullable<Awaited<ReturnType<typeof postPaymentsPaymentIdRefund>>>
    export type PostPaymentsPaymentIdRefundMutationBody = PostPaymentsPaymentIdRefundBody
    export type PostPaymentsPaymentIdRefundMutationError = AxiosError<PostPaymentsPaymentIdRefund400>

    /**
 * @summary Refund payment
 */
export const usePostPaymentsPaymentIdRefund = <TError = AxiosError<PostPaymentsPaymentIdRefund400>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPaymentsPaymentIdRefund>>, TError,{paymentId: string;data: PostPaymentsPaymentIdRefundBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postPaymentsPaymentIdRefund>>,
        TError,
        {paymentId: string;data: PostPaymentsPaymentIdRefundBody},
        TContext
      > => {

      const mutationOptions = getPostPaymentsPaymentIdRefundMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Handle Paystack webhook events for payment updates
 * @summary Paystack webhook handler
 */
export const postPaymentsWebhook = (
    postPaymentsWebhookBody: PostPaymentsWebhookBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostPaymentsWebhook200>> => {
    
    
    return axios.post(
      `http://localhost:4000/payments/webhook`,
      postPaymentsWebhookBody,options
    );
  }



export const getPostPaymentsWebhookMutationOptions = <TError = AxiosError<PostPaymentsWebhook401 | PostPaymentsWebhook500>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPaymentsWebhook>>, TError,{data: PostPaymentsWebhookBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postPaymentsWebhook>>, TError,{data: PostPaymentsWebhookBody}, TContext> => {

const mutationKey = ['postPaymentsWebhook'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPaymentsWebhook>>, {data: PostPaymentsWebhookBody}> = (props) => {
          const {data} = props ?? {};

          return  postPaymentsWebhook(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostPaymentsWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof postPaymentsWebhook>>>
    export type PostPaymentsWebhookMutationBody = PostPaymentsWebhookBody
    export type PostPaymentsWebhookMutationError = AxiosError<PostPaymentsWebhook401 | PostPaymentsWebhook500>

    /**
 * @summary Paystack webhook handler
 */
export const usePostPaymentsWebhook = <TError = AxiosError<PostPaymentsWebhook401 | PostPaymentsWebhook500>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPaymentsWebhook>>, TError,{data: PostPaymentsWebhookBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postPaymentsWebhook>>,
        TError,
        {data: PostPaymentsWebhookBody},
        TContext
      > => {

      const mutationOptions = getPostPaymentsWebhookMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    